package leetcode

import (
	"fmt"
	"math/bits"
	"sort"
	"unsafe"
)

// 1000以内的素数
var smallPrimeNums = []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997}

func IsPrime(n int) bool {
	// 	埃氏筛法步骤
	// （1）先把1删除（现今数学界1既不是质数也不是合数）
	// （2）读取队列中当前最小的数2,然后把2的倍数删去
	// （3）读取队列中当前最小的数3,然后把3的倍数删去
	// （4）读取队列中当前最小的数5,然后把5的倍数删去
	// （5）读取队列中当前最小的数7,然后把7的倍数删去
	// （6）继续下一个质数,同上
	// （7）如上所述直到需求的范围内所有的数均删除或读取
	// 注：此处的队列并非数据结构队列,如需保留运算结果,处于
	// 存储空间的充分利用以及大量删除操作的实施,建议采用链表的数据结构。

	if n <= 1 {
		return false
	} else if n <= 1000 {
		index := sort.SearchInts(smallPrimeNums, n)
		if index >= len(smallPrimeNums) {
			return false
		}

		return smallPrimeNums[index] == n

	} else {

		for i := 2; i*i <= n; i++ {
			if n%i == 0 {
				return false
			}
		}
		return true

		//  这道题的关键点就在于如何更有效的判断一个数为质数
		// 那么这里举几个例子
		// 比如16,那么有1*16,2*8,4*4,8*2,16*1这几个整数相乘的结果等于16。
		// 再来看一个,
		// 25,1*25,5*5,25*1
		// 20,1*20,2*10,4*5,5*4,10*2,20*1
		// 那么这里可以发现有如下规律：
		// 众多 i*j=n 中,总有一个小于并最接近sqrt(n)开根号的整数k,
		// 使得以后的所有i*j开始变成j*i,也就是说,从k以后,
		// 下一个i*j就会开始和前面的相同,所以这里可以将原本需要
		// 从1开始循环判断到n的量缩减到
		// 小于等于sqrt(n)
		//  如果 N  不是 质素  ,则一定存在一个  i  使得   i * [2,3,5,7] = N  (i  >=2  && i<= N-1 )

		//   https://zh.wikipedia.org/wiki/%E8%B4%A8%E6%95%B0
		//  100以内的质数有2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,在100内共有25个质数。

		//做这到题首先要知道什么是素数：只能被1和自身整除的数,有两种判断方法：

		// 1.用for循环,从2到n-1逐个求余,如果有被n整除的,则不是素数。

		// 2.m 不必被2~m-1之间的每一个整数去除,只需被2~√m之间的每一个整数去除就可以了。
		//    如果 m 不能被2~√m 间任一整数整除,m必定是素数。例如判别17是是否为素数,只需使17被2~4之间的每一个整数去除,由于都不能整除,可以判定17是素数。
		//    原因：因为如果m能被2~m-1之间任一整数整除,其二个因子必定有一个小于或等于√m,另一个大于或等于√m。

	}

}

func CountPrimes(n int) int {
	var r = make([]bool, n)
	// for i, _ := range r {
	// 	r[i] = true
	// }
	//---0,1 都是非素数
	r[0], r[1] = true, true
	var counter = 0
	for i := 2; i < n; i++ {
		if r[i] {

			continue
		}
		counter++
		for j := i * 2; j < n; j += i {
			r[j] = true
		}

	}

	fmt.Printf("%v\n", r)
	return counter

}

var mapx = map[string]int{
	"I": 1,
	// "IV": 4,
	"V": 5,
	// "IX": 9,
	"X": 10,
	// "XL": 40,
	"L": 50,
	// "XC": 90,
	"C": 100,
	// "CD": 400,
	"D": 500,
	// "CM": 900,
	"M": 1000,
}

func RomanToInt(s string) int {

	var lx = len(s)

	var res = 0
	var temp = 0

	var num = make([]int, lx)
	for ik := range s {
		num[ik] = mapx[s[ik:ik+1]]
	}

	fmt.Printf("%v\n", num)

	for i := 0; i < lx; i++ {
		if i+1 < lx && num[i] < num[i+1] {
			temp -= num[i]
			continue
		} else {
			temp += num[i]
		}
		res = res + temp
		temp = 0
	}
	return res

}

func HammingWeight(num uint32) int {

	return bits.OnesCount32(num)

	// var counter = 0

	// for num > 0 {
	// 	if num%2 == 1 {
	// 		counter = counter + 1
	// 	}
	// 	//---向右移动一位
	// 	num = num >> 1
	// }
	// return counter

}

func HammingDistance(x int, y int) int {

	// 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。
	// 给你两个整数 x 和 y，计算并返回它们之间的汉明距离。
	// 示例 1：
	// 输入：x = 1, y = 4
	// 输出：2
	// 解释：
	// 1   (0 0 0 1)
	// 4   (0 1 0 0)
	//        ↑   ↑
	// 上面的箭头指出了对应二进制位不同的位置。

	// 示例 2：
	// 输入：x = 3, y = 1
	// 3    (0  1  1)
	// 1    (0  0  1)
	// 输出：1
	// 提示：
	//    0 <= x, y <= 2^31 - 1

	if x == y {
		return 0
	}

	if x == ^y {
		return 31
	}

	var counter = 0
	for x > 0 || y > 0 {
		if x%2 != y%2 {
			counter++
		}
		//  x, y 都处以 2
		x = x >> 1
		y = y >> 1

	}

	return counter

}

func ReverseBits(num uint32) uint32 {
	var nb [4]byte
	//---转换为4个字节数组
	nb[0] = byte((num & 0xFF000000) >> 24)
	nb[1] = byte((num & 0x00FF0000) >> 16)
	nb[2] = byte((num & 0x0000FF00) >> 8)
	nb[3] = byte((num & 0x000000FF) >> 0)
	//---字节进行换转

	for i := 0; i < 4; i++ {
		var cb = nb[i]
		var rb byte = 0
		rb = (rb << 1) | ((cb & 0b10000000) >> 7)
		rb = (rb << 1) | ((cb & 0b01000000) >> 6)
		rb = (rb << 1) | ((cb & 0b00100000) >> 5)
		rb = (rb << 1) | ((cb & 0b00010000) >> 4)
		rb = (rb << 1) | ((cb & 0b00001000) >> 3)
		rb = (rb << 1) | ((cb & 0b00000100) >> 2)
		rb = (rb << 1) | ((cb & 0b00000010) >> 1)
		rb = (rb << 1) | (cb & 0b00000001)
		nb[i] = rb
	}

	nb[0], nb[1], nb[2], nb[3] = nb[3], nb[2], nb[1], nb[0]
	return *(*uint32)(unsafe.Pointer(&nb[0]))

	//[  0  ][  1  ][  2]  [  3]

	//---第4个字节和第1个字节交换

	//return bits.Reverse32(num)

	//  --

	// for i := 0; i < 32; i++ {

	// 	//--- res 左移1位
	// 	res = res << 1
	// 	// if num &1 == 1 {
	// 	// 	res = res + 1
	// 	// }

	// 	res = res + num&1

	// 	num = num >> 1

	// }

}
